{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nvar _require = require(\"./errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = require(\"./doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var i = 0, len = textMatchArray.length; i < len; i++) {\n    allMatches[textMatchArray[i]] = true;\n  }\n  for (var _i = 0, _len = othersMatchArray.length; _i < _len; _i++) {\n    allMatches[othersMatchArray[_i]] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  var delimiterWithErrors = delimiterMatches.reduce(function (delimiterAcc, currDelimiterMatch) {\n    var position = currDelimiterMatch.position;\n    var delimiterOffset = currDelimiterMatch.offset;\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    var lastDelimiterLength = lastDelimiterMatch.length;\n    xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n    if (inDelimiter && position === \"start\") {\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateOpenTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnclosedTagException({\n        xtag: wordToUtf8(xtag),\n        offset: lastDelimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    if (!inDelimiter && position === \"end\") {\n      if (syntaxOptions.allowUnopenedTag) {\n        return delimiterAcc;\n      }\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateCloseTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnopenedTagException({\n        xtag: xtag,\n        offset: delimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    inDelimiter = !inDelimiter;\n    lastDelimiterMatch = currDelimiterMatch;\n    delimiterAcc.push(currDelimiterMatch);\n    return delimiterAcc;\n  }, []);\n  if (inDelimiter) {\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n    errors.push(getUnclosedTagException({\n      xtag: wordToUtf8(xtag),\n      offset: lastDelimiterOffset\n    }));\n  }\n  return {\n    delimiterWithErrors: delimiterWithErrors,\n    errors: errors\n  };\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    _err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw _err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    // if tag starts with =, such as {=[ ]=}\n    if (compareResult === DELIMITER_START && fullText[offset + start.length] === \"=\") {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(\"=\", offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions),\n    delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors,\n    errors = _getDelimiterErrors.errors;\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])) {\n      delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    delimitersInOffset.forEach(function (delimiterInOffset) {\n      var value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        return;\n      }\n      if (value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: value\n        });\n        cursor += value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    });\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n  var inTextTag = false;\n  xmlparsed.forEach(function (part) {\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (fileType !== \"text\" && isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  });\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmllexed, delimiters, syntax, fileType) {\n    decodeContentParts(xmllexed, fileType);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    xmllexed.forEach(function (part) {\n      if (isInsideContent(part)) {\n        Array.prototype.push.apply(lexed, delimiterParsed[index].map(function (p) {\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n          return p;\n        }));\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    });\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      var value = content.substr(cursor, match.offset - cursor);\n      if (value.length > 0) {\n        parsed.push({\n          type: \"content\",\n          value: value\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n      return parsed;\n    }, []);\n    var value = content.substr(cursor);\n    if (value.length > 0) {\n      parsed.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parsed;\n  }\n};","map":{"version":3,"names":["_typeof","o","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","TypeError","minLen","_arrayLikeToArray","n","Object","toString","call","slice","name","Array","from","test","len","length","arr2","r","l","t","e","u","a","f","next","done","push","value","isArray","ownKeys","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","enumerable","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","key","_toPropertyKey","configurable","writable","_toPrimitive","toPrimitive","String","Number","_require","require","getUnclosedTagException","getUnopenedTagException","getDuplicateOpenTagException","getDuplicateCloseTagException","throwMalformedXml","throwXmlInvalid","XTTemplateError","_require2","isTextStart","isTextEnd","wordToUtf8","DELIMITER_NONE","DELIMITER_EQUAL","DELIMITER_START","DELIMITER_END","inRange","range","match","offset","updateInTextTag","part","inTextTag","getTag","tag","position","start","end","indexOf","tagMatcher","content","textMatchArray","othersMatchArray","cursor","contentLength","allMatches","_i","_len","totalMatches","nextOpening","tagText","_getTag","text","type","getDelimiterErrors","delimiterMatches","fullText","syntaxOptions","errors","inDelimiter","lastDelimiterMatch","xtag","delimiterWithErrors","reduce","delimiterAcc","currDelimiterMatch","delimiterOffset","lastDelimiterOffset","lastDelimiterLength","substr","error","allowUnopenedTag","compareOffsets","startOffset","endOffset","splitDelimiters","inside","newDelimiters","split","err","properties","id","explanation","_newDelimiters","_err","getAllDelimiterIndexes","delimiters","indexes","insideTag","compareResult","changedelimiter","nextEqual","nextEndOffset","_insideTag","_splitDelimiters","_splitDelimiters2","parseDelimiters","innerContentParts","full","map","p","join","ranges","lIndex","_getDelimiterErrors","cutNext","delimiterIndex","parsed","partContent","delimitersInOffset","parts","delimiterInOffset","delimiterPart","isInsideContent","getContentParts","xmlparsed","decodeContentParts","fileType","replace","module","exports","parse","xmllexed","syntax","_parseDelimiters","delimiterParsed","lexed","index","xmlparse","xmltags","matches","other"],"sources":["C:/study/react project/client/node_modules/docxtemplater/js/lexer.js"],"sourcesContent":["\"use strict\";\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = require(\"./errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = require(\"./doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var i = 0, len = textMatchArray.length; i < len; i++) {\n    allMatches[textMatchArray[i]] = true;\n  }\n  for (var _i = 0, _len = othersMatchArray.length; _i < _len; _i++) {\n    allMatches[othersMatchArray[_i]] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  var delimiterWithErrors = delimiterMatches.reduce(function (delimiterAcc, currDelimiterMatch) {\n    var position = currDelimiterMatch.position;\n    var delimiterOffset = currDelimiterMatch.offset;\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    var lastDelimiterLength = lastDelimiterMatch.length;\n    xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n    if (inDelimiter && position === \"start\") {\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateOpenTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnclosedTagException({\n        xtag: wordToUtf8(xtag),\n        offset: lastDelimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    if (!inDelimiter && position === \"end\") {\n      if (syntaxOptions.allowUnopenedTag) {\n        return delimiterAcc;\n      }\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateCloseTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnopenedTagException({\n        xtag: xtag,\n        offset: delimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    inDelimiter = !inDelimiter;\n    lastDelimiterMatch = currDelimiterMatch;\n    delimiterAcc.push(currDelimiterMatch);\n    return delimiterAcc;\n  }, []);\n  if (inDelimiter) {\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n    errors.push(getUnclosedTagException({\n      xtag: wordToUtf8(xtag),\n      offset: lastDelimiterOffset\n    }));\n  }\n  return {\n    delimiterWithErrors: delimiterWithErrors,\n    errors: errors\n  };\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    _err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw _err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    // if tag starts with =, such as {=[ ]=}\n    if (compareResult === DELIMITER_START && fullText[offset + start.length] === \"=\") {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(\"=\", offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions),\n    delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors,\n    errors = _getDelimiterErrors.errors;\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])) {\n      delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    delimitersInOffset.forEach(function (delimiterInOffset) {\n      var value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        return;\n      }\n      if (value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: value\n        });\n        cursor += value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    });\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n  var inTextTag = false;\n  xmlparsed.forEach(function (part) {\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (fileType !== \"text\" && isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  });\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmllexed, delimiters, syntax, fileType) {\n    decodeContentParts(xmllexed, fileType);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    xmllexed.forEach(function (part) {\n      if (isInsideContent(part)) {\n        Array.prototype.push.apply(lexed, delimiterParsed[index].map(function (p) {\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n          return p;\n        }));\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    });\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      var value = content.substr(cursor, match.offset - cursor);\n      if (value.length > 0) {\n        parsed.push({\n          type: \"content\",\n          value: value\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n      return parsed;\n    }, []);\n    var value = content.substr(cursor);\n    if (value.length > 0) {\n      parsed.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parsed;\n  }\n};"],"mappings":"AAAA,YAAY;;AAEZ,SAASA,OAAOA,CAACC,CAAC,EAAE;EAAE,yBAAyB;;EAAE,OAAOD,OAAO,GAAG,UAAU,IAAI,OAAOE,MAAM,IAAI,QAAQ,IAAI,OAAOA,MAAM,CAACC,QAAQ,GAAG,UAAUF,CAAC,EAAE;IAAE,OAAO,OAAOA,CAAC;EAAE,CAAC,GAAG,UAAUA,CAAC,EAAE;IAAE,OAAOA,CAAC,IAAI,UAAU,IAAI,OAAOC,MAAM,IAAID,CAAC,CAACG,WAAW,KAAKF,MAAM,IAAID,CAAC,KAAKC,MAAM,CAACG,SAAS,GAAG,QAAQ,GAAG,OAAOJ,CAAC;EAAE,CAAC,EAAED,OAAO,CAACC,CAAC,CAAC;AAAE;AAC7T,SAASK,cAAcA,CAACC,GAAG,EAAEC,CAAC,EAAE;EAAE,OAAOC,eAAe,CAACF,GAAG,CAAC,IAAIG,qBAAqB,CAACH,GAAG,EAAEC,CAAC,CAAC,IAAIG,2BAA2B,CAACJ,GAAG,EAAEC,CAAC,CAAC,IAAII,gBAAgB,CAAC,CAAC;AAAE;AAC7J,SAASA,gBAAgBA,CAAA,EAAG;EAAE,MAAM,IAAIC,SAAS,CAAC,2IAA2I,CAAC;AAAE;AAChM,SAASF,2BAA2BA,CAACV,CAAC,EAAEa,MAAM,EAAE;EAAE,IAAI,CAACb,CAAC,EAAE;EAAQ,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE,OAAOc,iBAAiB,CAACd,CAAC,EAAEa,MAAM,CAAC;EAAE,IAAIE,CAAC,GAAGC,MAAM,CAACZ,SAAS,CAACa,QAAQ,CAACC,IAAI,CAAClB,CAAC,CAAC,CAACmB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAAE,IAAIJ,CAAC,KAAK,QAAQ,IAAIf,CAAC,CAACG,WAAW,EAAEY,CAAC,GAAGf,CAAC,CAACG,WAAW,CAACiB,IAAI;EAAE,IAAIL,CAAC,KAAK,KAAK,IAAIA,CAAC,KAAK,KAAK,EAAE,OAAOM,KAAK,CAACC,IAAI,CAACtB,CAAC,CAAC;EAAE,IAAIe,CAAC,KAAK,WAAW,IAAI,0CAA0C,CAACQ,IAAI,CAACR,CAAC,CAAC,EAAE,OAAOD,iBAAiB,CAACd,CAAC,EAAEa,MAAM,CAAC;AAAE;AAC/Z,SAASC,iBAAiBA,CAACR,GAAG,EAAEkB,GAAG,EAAE;EAAE,IAAIA,GAAG,IAAI,IAAI,IAAIA,GAAG,GAAGlB,GAAG,CAACmB,MAAM,EAAED,GAAG,GAAGlB,GAAG,CAACmB,MAAM;EAAE,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEmB,IAAI,GAAG,IAAIL,KAAK,CAACG,GAAG,CAAC,EAAEjB,CAAC,GAAGiB,GAAG,EAAEjB,CAAC,EAAE,EAAEmB,IAAI,CAACnB,CAAC,CAAC,GAAGD,GAAG,CAACC,CAAC,CAAC;EAAE,OAAOmB,IAAI;AAAE;AAClL,SAASjB,qBAAqBA,CAACkB,CAAC,EAAEC,CAAC,EAAE;EAAE,IAAIC,CAAC,GAAG,IAAI,IAAIF,CAAC,GAAG,IAAI,GAAG,WAAW,IAAI,OAAO1B,MAAM,IAAI0B,CAAC,CAAC1B,MAAM,CAACC,QAAQ,CAAC,IAAIyB,CAAC,CAAC,YAAY,CAAC;EAAE,IAAI,IAAI,IAAIE,CAAC,EAAE;IAAE,IAAIC,CAAC;MAAEf,CAAC;MAAER,CAAC;MAAEwB,CAAC;MAAEC,CAAC,GAAG,EAAE;MAAEC,CAAC,GAAG,CAAC,CAAC;MAAEjC,CAAC,GAAG,CAAC,CAAC;IAAE,IAAI;MAAE,IAAIO,CAAC,GAAG,CAACsB,CAAC,GAAGA,CAAC,CAACX,IAAI,CAACS,CAAC,CAAC,EAAEO,IAAI,EAAE,CAAC,KAAKN,CAAC,EAAE;QAAE,IAAIZ,MAAM,CAACa,CAAC,CAAC,KAAKA,CAAC,EAAE;QAAQI,CAAC,GAAG,CAAC,CAAC;MAAE,CAAC,MAAM,OAAO,EAAEA,CAAC,GAAG,CAACH,CAAC,GAAGvB,CAAC,CAACW,IAAI,CAACW,CAAC,CAAC,EAAEM,IAAI,CAAC,KAAKH,CAAC,CAACI,IAAI,CAACN,CAAC,CAACO,KAAK,CAAC,EAAEL,CAAC,CAACP,MAAM,KAAKG,CAAC,CAAC,EAAEK,CAAC,GAAG,CAAC,CAAC,CAAC;IAAE,CAAC,CAAC,OAAON,CAAC,EAAE;MAAE3B,CAAC,GAAG,CAAC,CAAC,EAAEe,CAAC,GAAGY,CAAC;IAAE,CAAC,SAAS;MAAE,IAAI;QAAE,IAAI,CAACM,CAAC,IAAI,IAAI,IAAIJ,CAAC,CAAC,QAAQ,CAAC,KAAKE,CAAC,GAAGF,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAEb,MAAM,CAACe,CAAC,CAAC,KAAKA,CAAC,CAAC,EAAE;MAAQ,CAAC,SAAS;QAAE,IAAI/B,CAAC,EAAE,MAAMe,CAAC;MAAE;IAAE;IAAE,OAAOiB,CAAC;EAAE;AAAE;AACzhB,SAASxB,eAAeA,CAACF,GAAG,EAAE;EAAE,IAAIe,KAAK,CAACiB,OAAO,CAAChC,GAAG,CAAC,EAAE,OAAOA,GAAG;AAAE;AACpE,SAASiC,OAAOA,CAACT,CAAC,EAAEH,CAAC,EAAE;EAAE,IAAIE,CAAC,GAAGb,MAAM,CAACwB,IAAI,CAACV,CAAC,CAAC;EAAE,IAAId,MAAM,CAACyB,qBAAqB,EAAE;IAAE,IAAIzC,CAAC,GAAGgB,MAAM,CAACyB,qBAAqB,CAACX,CAAC,CAAC;IAAEH,CAAC,KAAK3B,CAAC,GAAGA,CAAC,CAAC0C,MAAM,CAAC,UAAUf,CAAC,EAAE;MAAE,OAAOX,MAAM,CAAC2B,wBAAwB,CAACb,CAAC,EAAEH,CAAC,CAAC,CAACiB,UAAU;IAAE,CAAC,CAAC,CAAC,EAAEf,CAAC,CAACO,IAAI,CAACS,KAAK,CAAChB,CAAC,EAAE7B,CAAC,CAAC;EAAE;EAAE,OAAO6B,CAAC;AAAE;AAC9P,SAASiB,aAAaA,CAAChB,CAAC,EAAE;EAAE,KAAK,IAAIH,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,SAAS,CAACtB,MAAM,EAAEE,CAAC,EAAE,EAAE;IAAE,IAAIE,CAAC,GAAG,IAAI,IAAIkB,SAAS,CAACpB,CAAC,CAAC,GAAGoB,SAAS,CAACpB,CAAC,CAAC,GAAG,CAAC,CAAC;IAAEA,CAAC,GAAG,CAAC,GAAGY,OAAO,CAACvB,MAAM,CAACa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACmB,OAAO,CAAC,UAAUrB,CAAC,EAAE;MAAEsB,eAAe,CAACnB,CAAC,EAAEH,CAAC,EAAEE,CAAC,CAACF,CAAC,CAAC,CAAC;IAAE,CAAC,CAAC,GAAGX,MAAM,CAACkC,yBAAyB,GAAGlC,MAAM,CAACmC,gBAAgB,CAACrB,CAAC,EAAEd,MAAM,CAACkC,yBAAyB,CAACrB,CAAC,CAAC,CAAC,GAAGU,OAAO,CAACvB,MAAM,CAACa,CAAC,CAAC,CAAC,CAACmB,OAAO,CAAC,UAAUrB,CAAC,EAAE;MAAEX,MAAM,CAACoC,cAAc,CAACtB,CAAC,EAAEH,CAAC,EAAEX,MAAM,CAAC2B,wBAAwB,CAACd,CAAC,EAAEF,CAAC,CAAC,CAAC;IAAE,CAAC,CAAC;EAAE;EAAE,OAAOG,CAAC;AAAE;AACtb,SAASmB,eAAeA,CAACI,GAAG,EAAEC,GAAG,EAAEjB,KAAK,EAAE;EAAEiB,GAAG,GAAGC,cAAc,CAACD,GAAG,CAAC;EAAE,IAAIA,GAAG,IAAID,GAAG,EAAE;IAAErC,MAAM,CAACoC,cAAc,CAACC,GAAG,EAAEC,GAAG,EAAE;MAAEjB,KAAK,EAAEA,KAAK;MAAEO,UAAU,EAAE,IAAI;MAAEY,YAAY,EAAE,IAAI;MAAEC,QAAQ,EAAE;IAAK,CAAC,CAAC;EAAE,CAAC,MAAM;IAAEJ,GAAG,CAACC,GAAG,CAAC,GAAGjB,KAAK;EAAE;EAAE,OAAOgB,GAAG;AAAE;AAC3O,SAASE,cAAcA,CAAC1B,CAAC,EAAE;EAAE,IAAItB,CAAC,GAAGmD,YAAY,CAAC7B,CAAC,EAAE,QAAQ,CAAC;EAAE,OAAO,QAAQ,IAAI9B,OAAO,CAACQ,CAAC,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,EAAE;AAAE;AAC5G,SAASmD,YAAYA,CAAC7B,CAAC,EAAEF,CAAC,EAAE;EAAE,IAAI,QAAQ,IAAI5B,OAAO,CAAC8B,CAAC,CAAC,IAAI,CAACA,CAAC,EAAE,OAAOA,CAAC;EAAE,IAAIC,CAAC,GAAGD,CAAC,CAAC5B,MAAM,CAAC0D,WAAW,CAAC;EAAE,IAAI,KAAK,CAAC,KAAK7B,CAAC,EAAE;IAAE,IAAIvB,CAAC,GAAGuB,CAAC,CAACZ,IAAI,CAACW,CAAC,EAAEF,CAAC,IAAI,SAAS,CAAC;IAAE,IAAI,QAAQ,IAAI5B,OAAO,CAACQ,CAAC,CAAC,EAAE,OAAOA,CAAC;IAAE,MAAM,IAAIK,SAAS,CAAC,8CAA8C,CAAC;EAAE;EAAE,OAAO,CAAC,QAAQ,KAAKe,CAAC,GAAGiC,MAAM,GAAGC,MAAM,EAAEhC,CAAC,CAAC;AAAE;AAC3T,IAAIiC,QAAQ,GAAGC,OAAO,CAAC,aAAa,CAAC;EACnCC,uBAAuB,GAAGF,QAAQ,CAACE,uBAAuB;EAC1DC,uBAAuB,GAAGH,QAAQ,CAACG,uBAAuB;EAC1DC,4BAA4B,GAAGJ,QAAQ,CAACI,4BAA4B;EACpEC,6BAA6B,GAAGL,QAAQ,CAACK,6BAA6B;EACtEC,iBAAiB,GAAGN,QAAQ,CAACM,iBAAiB;EAC9CC,eAAe,GAAGP,QAAQ,CAACO,eAAe;EAC1CC,eAAe,GAAGR,QAAQ,CAACQ,eAAe;AAC5C,IAAIC,SAAS,GAAGR,OAAO,CAAC,gBAAgB,CAAC;EACvCS,WAAW,GAAGD,SAAS,CAACC,WAAW;EACnCC,SAAS,GAAGF,SAAS,CAACE,SAAS;EAC/BC,UAAU,GAAGH,SAAS,CAACG,UAAU;AACnC,IAAIC,cAAc,GAAG,CAAC;EACpBC,eAAe,GAAG,CAAC;EACnBC,eAAe,GAAG,CAAC;EACnBC,aAAa,GAAG,CAAC;AACnB,SAASC,OAAOA,CAACC,KAAK,EAAEC,KAAK,EAAE;EAC7B,OAAOD,KAAK,CAAC,CAAC,CAAC,IAAIC,KAAK,CAACC,MAAM,IAAID,KAAK,CAACC,MAAM,GAAGF,KAAK,CAAC,CAAC,CAAC;AAC5D;AACA,SAASG,eAAeA,CAACC,IAAI,EAAEC,SAAS,EAAE;EACxC,IAAIb,WAAW,CAACY,IAAI,CAAC,EAAE;IACrB,IAAIC,SAAS,EAAE;MACbjB,iBAAiB,CAAC,CAAC;IACrB;IACA,OAAO,IAAI;EACb;EACA,IAAIK,SAAS,CAACW,IAAI,CAAC,EAAE;IACnB,IAAI,CAACC,SAAS,EAAE;MACdjB,iBAAiB,CAAC,CAAC;IACrB;IACA,OAAO,KAAK;EACd;EACA,OAAOiB,SAAS;AAClB;AACA,SAASC,MAAMA,CAACC,GAAG,EAAE;EACnB,IAAIC,QAAQ,GAAG,EAAE;EACjB,IAAIC,KAAK,GAAG,CAAC;EACb,IAAIC,GAAG,GAAGH,GAAG,CAACI,OAAO,CAAC,GAAG,CAAC;EAC1B,IAAIJ,GAAG,CAACA,GAAG,CAAC9D,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;IAC/B+D,QAAQ,GAAG,aAAa;IACxB,IAAIE,GAAG,KAAK,CAAC,CAAC,EAAE;MACdA,GAAG,GAAGH,GAAG,CAAC9D,MAAM,GAAG,CAAC;IACtB;EACF,CAAC,MAAM,IAAI8D,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;IACzBE,KAAK,GAAG,CAAC;IACTD,QAAQ,GAAG,KAAK;IAChB,IAAIE,GAAG,KAAK,CAAC,CAAC,EAAE;MACdA,GAAG,GAAGH,GAAG,CAAC9D,MAAM,GAAG,CAAC;IACtB;EACF,CAAC,MAAM;IACL+D,QAAQ,GAAG,OAAO;IAClB,IAAIE,GAAG,KAAK,CAAC,CAAC,EAAE;MACdA,GAAG,GAAGH,GAAG,CAAC9D,MAAM,GAAG,CAAC;IACtB;EACF;EACA,OAAO;IACL8D,GAAG,EAAEA,GAAG,CAACpE,KAAK,CAACsE,KAAK,EAAEC,GAAG,CAAC;IAC1BF,QAAQ,EAAEA;EACZ,CAAC;AACH;AACA,SAASI,UAAUA,CAACC,OAAO,EAAEC,cAAc,EAAEC,gBAAgB,EAAE;EAC7D,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIC,aAAa,GAAGJ,OAAO,CAACpE,MAAM;EAClC,IAAIyE,UAAU,GAAG,CAAC,CAAC;EACnB,KAAK,IAAI3F,CAAC,GAAG,CAAC,EAAEiB,GAAG,GAAGsE,cAAc,CAACrE,MAAM,EAAElB,CAAC,GAAGiB,GAAG,EAAEjB,CAAC,EAAE,EAAE;IACzD2F,UAAU,CAACJ,cAAc,CAACvF,CAAC,CAAC,CAAC,GAAG,IAAI;EACtC;EACA,KAAK,IAAI4F,EAAE,GAAG,CAAC,EAAEC,IAAI,GAAGL,gBAAgB,CAACtE,MAAM,EAAE0E,EAAE,GAAGC,IAAI,EAAED,EAAE,EAAE,EAAE;IAChED,UAAU,CAACH,gBAAgB,CAACI,EAAE,CAAC,CAAC,GAAG,KAAK;EAC1C;EACA,IAAIE,YAAY,GAAG,EAAE;EACrB,OAAOL,MAAM,GAAGC,aAAa,EAAE;IAC7BD,MAAM,GAAGH,OAAO,CAACF,OAAO,CAAC,GAAG,EAAEK,MAAM,CAAC;IACrC,IAAIA,MAAM,KAAK,CAAC,CAAC,EAAE;MACjB;IACF;IACA,IAAId,MAAM,GAAGc,MAAM;IACnB,IAAIM,WAAW,GAAGT,OAAO,CAACF,OAAO,CAAC,GAAG,EAAEK,MAAM,GAAG,CAAC,CAAC;IAClDA,MAAM,GAAGH,OAAO,CAACF,OAAO,CAAC,GAAG,EAAEK,MAAM,CAAC;IACrC,IAAIA,MAAM,KAAK,CAAC,CAAC,IAAIM,WAAW,KAAK,CAAC,CAAC,IAAIN,MAAM,GAAGM,WAAW,EAAE;MAC/DjC,eAAe,CAACwB,OAAO,EAAEX,MAAM,CAAC;IAClC;IACA,IAAIqB,OAAO,GAAGV,OAAO,CAAC1E,KAAK,CAAC+D,MAAM,EAAEc,MAAM,GAAG,CAAC,CAAC;IAC/C,IAAIQ,OAAO,GAAGlB,MAAM,CAACiB,OAAO,CAAC;MAC3BhB,GAAG,GAAGiB,OAAO,CAACjB,GAAG;MACjBC,QAAQ,GAAGgB,OAAO,CAAChB,QAAQ;IAC7B,IAAIiB,IAAI,GAAGP,UAAU,CAACX,GAAG,CAAC;IAC1B,IAAIkB,IAAI,IAAI,IAAI,EAAE;MAChB;IACF;IACAJ,YAAY,CAACjE,IAAI,CAAC;MAChBsE,IAAI,EAAE,KAAK;MACXlB,QAAQ,EAAEA,QAAQ;MAClBiB,IAAI,EAAEA,IAAI;MACVvB,MAAM,EAAEA,MAAM;MACd7C,KAAK,EAAEkE,OAAO;MACdhB,GAAG,EAAEA;IACP,CAAC,CAAC;EACJ;EACA,OAAOc,YAAY;AACrB;AACA,SAASM,kBAAkBA,CAACC,gBAAgB,EAAEC,QAAQ,EAAEC,aAAa,EAAE;EACrE,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,WAAW,GAAG,KAAK;EACvB,IAAIC,kBAAkB,GAAG;IACvB/B,MAAM,EAAE;EACV,CAAC;EACD,IAAIgC,IAAI;EACR,IAAIC,mBAAmB,GAAGP,gBAAgB,CAACQ,MAAM,CAAC,UAAUC,YAAY,EAAEC,kBAAkB,EAAE;IAC5F,IAAI9B,QAAQ,GAAG8B,kBAAkB,CAAC9B,QAAQ;IAC1C,IAAI+B,eAAe,GAAGD,kBAAkB,CAACpC,MAAM;IAC/C,IAAIsC,mBAAmB,GAAGP,kBAAkB,CAAC/B,MAAM;IACnD,IAAIuC,mBAAmB,GAAGR,kBAAkB,CAACxF,MAAM;IACnDyF,IAAI,GAAGL,QAAQ,CAACa,MAAM,CAACF,mBAAmB,EAAED,eAAe,GAAGC,mBAAmB,CAAC;IAClF,IAAIR,WAAW,IAAIxB,QAAQ,KAAK,OAAO,EAAE;MACvC,IAAIgC,mBAAmB,GAAGC,mBAAmB,KAAKF,eAAe,EAAE;QACjEL,IAAI,GAAGL,QAAQ,CAACa,MAAM,CAACF,mBAAmB,EAAED,eAAe,GAAGC,mBAAmB,GAAGC,mBAAmB,GAAG,CAAC,CAAC;QAC5GV,MAAM,CAAC3E,IAAI,CAAC8B,4BAA4B,CAAC;UACvCgD,IAAI,EAAEA,IAAI;UACVhC,MAAM,EAAEsC;QACV,CAAC,CAAC,CAAC;QACHP,kBAAkB,GAAGK,kBAAkB;QACvCD,YAAY,CAACjF,IAAI,CAACU,aAAa,CAACA,aAAa,CAAC,CAAC,CAAC,EAAEwE,kBAAkB,CAAC,EAAE,CAAC,CAAC,EAAE;UACzEK,KAAK,EAAE;QACT,CAAC,CAAC,CAAC;QACH,OAAON,YAAY;MACrB;MACAN,MAAM,CAAC3E,IAAI,CAAC4B,uBAAuB,CAAC;QAClCkD,IAAI,EAAExC,UAAU,CAACwC,IAAI,CAAC;QACtBhC,MAAM,EAAEsC;MACV,CAAC,CAAC,CAAC;MACHP,kBAAkB,GAAGK,kBAAkB;MACvCD,YAAY,CAACjF,IAAI,CAACU,aAAa,CAACA,aAAa,CAAC,CAAC,CAAC,EAAEwE,kBAAkB,CAAC,EAAE,CAAC,CAAC,EAAE;QACzEK,KAAK,EAAE;MACT,CAAC,CAAC,CAAC;MACH,OAAON,YAAY;IACrB;IACA,IAAI,CAACL,WAAW,IAAIxB,QAAQ,KAAK,KAAK,EAAE;MACtC,IAAIsB,aAAa,CAACc,gBAAgB,EAAE;QAClC,OAAOP,YAAY;MACrB;MACA,IAAIG,mBAAmB,GAAGC,mBAAmB,KAAKF,eAAe,EAAE;QACjEL,IAAI,GAAGL,QAAQ,CAACa,MAAM,CAACF,mBAAmB,GAAG,CAAC,EAAED,eAAe,GAAGC,mBAAmB,GAAGC,mBAAmB,GAAG,CAAC,CAAC;QAChHV,MAAM,CAAC3E,IAAI,CAAC+B,6BAA6B,CAAC;UACxC+C,IAAI,EAAEA,IAAI;UACVhC,MAAM,EAAEsC;QACV,CAAC,CAAC,CAAC;QACHP,kBAAkB,GAAGK,kBAAkB;QACvCD,YAAY,CAACjF,IAAI,CAACU,aAAa,CAACA,aAAa,CAAC,CAAC,CAAC,EAAEwE,kBAAkB,CAAC,EAAE,CAAC,CAAC,EAAE;UACzEK,KAAK,EAAE;QACT,CAAC,CAAC,CAAC;QACH,OAAON,YAAY;MACrB;MACAN,MAAM,CAAC3E,IAAI,CAAC6B,uBAAuB,CAAC;QAClCiD,IAAI,EAAEA,IAAI;QACVhC,MAAM,EAAEqC;MACV,CAAC,CAAC,CAAC;MACHN,kBAAkB,GAAGK,kBAAkB;MACvCD,YAAY,CAACjF,IAAI,CAACU,aAAa,CAACA,aAAa,CAAC,CAAC,CAAC,EAAEwE,kBAAkB,CAAC,EAAE,CAAC,CAAC,EAAE;QACzEK,KAAK,EAAE;MACT,CAAC,CAAC,CAAC;MACH,OAAON,YAAY;IACrB;IACAL,WAAW,GAAG,CAACA,WAAW;IAC1BC,kBAAkB,GAAGK,kBAAkB;IACvCD,YAAY,CAACjF,IAAI,CAACkF,kBAAkB,CAAC;IACrC,OAAOD,YAAY;EACrB,CAAC,EAAE,EAAE,CAAC;EACN,IAAIL,WAAW,EAAE;IACf,IAAIQ,mBAAmB,GAAGP,kBAAkB,CAAC/B,MAAM;IACnDgC,IAAI,GAAGL,QAAQ,CAACa,MAAM,CAACF,mBAAmB,EAAEX,QAAQ,CAACpF,MAAM,GAAG+F,mBAAmB,CAAC;IAClFT,MAAM,CAAC3E,IAAI,CAAC4B,uBAAuB,CAAC;MAClCkD,IAAI,EAAExC,UAAU,CAACwC,IAAI,CAAC;MACtBhC,MAAM,EAAEsC;IACV,CAAC,CAAC,CAAC;EACL;EACA,OAAO;IACLL,mBAAmB,EAAEA,mBAAmB;IACxCJ,MAAM,EAAEA;EACV,CAAC;AACH;AACA,SAASc,cAAcA,CAACC,WAAW,EAAEC,SAAS,EAAE;EAC9C,IAAID,WAAW,KAAK,CAAC,CAAC,IAAIC,SAAS,KAAK,CAAC,CAAC,EAAE;IAC1C,OAAOpD,cAAc;EACvB;EACA,IAAImD,WAAW,KAAKC,SAAS,EAAE;IAC7B,OAAOnD,eAAe;EACxB;EACA,IAAIkD,WAAW,KAAK,CAAC,CAAC,IAAIC,SAAS,KAAK,CAAC,CAAC,EAAE;IAC1C,OAAOA,SAAS,GAAGD,WAAW,GAAGjD,eAAe,GAAGC,aAAa;EAClE;EACA,OAAOgD,WAAW,GAAGC,SAAS,GAAGlD,eAAe,GAAGC,aAAa;AAClE;AACA,SAASkD,eAAeA,CAACC,MAAM,EAAE;EAC/B,IAAIC,aAAa,GAAGD,MAAM,CAACE,KAAK,CAAC,GAAG,CAAC;EACrC,IAAID,aAAa,CAACzG,MAAM,KAAK,CAAC,EAAE;IAC9B,IAAI2G,GAAG,GAAG,IAAI9D,eAAe,CAAC,iCAAiC,CAAC;IAChE8D,GAAG,CAACC,UAAU,GAAG;MACfC,EAAE,EAAE,2BAA2B;MAC/BC,WAAW,EAAE;IACf,CAAC;IACD,MAAMH,GAAG;EACX;EACA,IAAII,cAAc,GAAGnI,cAAc,CAAC6H,aAAa,EAAE,CAAC,CAAC;IACnDzC,KAAK,GAAG+C,cAAc,CAAC,CAAC,CAAC;IACzB9C,GAAG,GAAG8C,cAAc,CAAC,CAAC,CAAC;EACzB,IAAI/C,KAAK,CAAChE,MAAM,KAAK,CAAC,IAAIiE,GAAG,CAACjE,MAAM,KAAK,CAAC,EAAE;IAC1C,IAAIgH,IAAI,GAAG,IAAInE,eAAe,CAAC,iCAAiC,CAAC;IACjEmE,IAAI,CAACJ,UAAU,GAAG;MAChBC,EAAE,EAAE,2BAA2B;MAC/BC,WAAW,EAAE;IACf,CAAC;IACD,MAAME,IAAI;EACZ;EACA,OAAO,CAAChD,KAAK,EAAEC,GAAG,CAAC;AACrB;AACA,SAASgD,sBAAsBA,CAAC7B,QAAQ,EAAE8B,UAAU,EAAE;EACpD,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAInD,KAAK,GAAGkD,UAAU,CAAClD,KAAK;IAC1BC,GAAG,GAAGiD,UAAU,CAACjD,GAAG;EACtB,IAAIR,MAAM,GAAG,CAAC,CAAC;EACf,IAAI2D,SAAS,GAAG,KAAK;EACrB,OAAO,IAAI,EAAE;IACX,IAAIf,WAAW,GAAGjB,QAAQ,CAAClB,OAAO,CAACF,KAAK,EAAEP,MAAM,GAAG,CAAC,CAAC;IACrD,IAAI6C,SAAS,GAAGlB,QAAQ,CAAClB,OAAO,CAACD,GAAG,EAAER,MAAM,GAAG,CAAC,CAAC;IACjD,IAAIM,QAAQ,GAAG,IAAI;IACnB,IAAIhE,GAAG,GAAG,KAAK,CAAC;IAChB,IAAIsH,aAAa,GAAGjB,cAAc,CAACC,WAAW,EAAEC,SAAS,CAAC;IAC1D,IAAIe,aAAa,KAAKlE,eAAe,EAAE;MACrCkE,aAAa,GAAGD,SAAS,GAAG/D,aAAa,GAAGD,eAAe;IAC7D;IACA,QAAQiE,aAAa;MACnB,KAAKnE,cAAc;QACjB,OAAOiE,OAAO;MAChB,KAAK9D,aAAa;QAChB+D,SAAS,GAAG,KAAK;QACjB3D,MAAM,GAAG6C,SAAS;QAClBvC,QAAQ,GAAG,KAAK;QAChBhE,GAAG,GAAGkE,GAAG,CAACjE,MAAM;QAChB;MACF,KAAKoD,eAAe;QAClBgE,SAAS,GAAG,IAAI;QAChB3D,MAAM,GAAG4C,WAAW;QACpBtC,QAAQ,GAAG,OAAO;QAClBhE,GAAG,GAAGiE,KAAK,CAAChE,MAAM;QAClB;IACJ;IACA;IACA,IAAIqH,aAAa,KAAKjE,eAAe,IAAIgC,QAAQ,CAAC3B,MAAM,GAAGO,KAAK,CAAChE,MAAM,CAAC,KAAK,GAAG,EAAE;MAChFmH,OAAO,CAACxG,IAAI,CAAC;QACX8C,MAAM,EAAE4C,WAAW;QACnBtC,QAAQ,EAAE,OAAO;QACjB/D,MAAM,EAAEgE,KAAK,CAAChE,MAAM;QACpBsH,eAAe,EAAE;MACnB,CAAC,CAAC;MACF,IAAIC,SAAS,GAAGnC,QAAQ,CAAClB,OAAO,CAAC,GAAG,EAAET,MAAM,GAAGO,KAAK,CAAChE,MAAM,GAAG,CAAC,CAAC;MAChE,IAAIwH,aAAa,GAAGpC,QAAQ,CAAClB,OAAO,CAACD,GAAG,EAAEsD,SAAS,GAAG,CAAC,CAAC;MACxDJ,OAAO,CAACxG,IAAI,CAAC;QACX8C,MAAM,EAAE+D,aAAa;QACrBzD,QAAQ,EAAE,KAAK;QACf/D,MAAM,EAAEiE,GAAG,CAACjE,MAAM;QAClBsH,eAAe,EAAE;MACnB,CAAC,CAAC;MACF,IAAIG,UAAU,GAAGrC,QAAQ,CAACa,MAAM,CAACxC,MAAM,GAAGO,KAAK,CAAChE,MAAM,GAAG,CAAC,EAAEuH,SAAS,GAAG9D,MAAM,GAAGO,KAAK,CAAChE,MAAM,GAAG,CAAC,CAAC;MAClG,IAAI0H,gBAAgB,GAAGnB,eAAe,CAACkB,UAAU,CAAC;MAClD,IAAIE,iBAAiB,GAAG/I,cAAc,CAAC8I,gBAAgB,EAAE,CAAC,CAAC;MAC3D1D,KAAK,GAAG2D,iBAAiB,CAAC,CAAC,CAAC;MAC5B1D,GAAG,GAAG0D,iBAAiB,CAAC,CAAC,CAAC;MAC1BlE,MAAM,GAAG+D,aAAa;MACtB;IACF;IACAL,OAAO,CAACxG,IAAI,CAAC;MACX8C,MAAM,EAAEA,MAAM;MACdM,QAAQ,EAAEA,QAAQ;MAClB/D,MAAM,EAAED;IACV,CAAC,CAAC;EACJ;AACF;AACA,SAAS6H,eAAeA,CAACC,iBAAiB,EAAEX,UAAU,EAAE7B,aAAa,EAAE;EACrE,IAAIyC,IAAI,GAAGD,iBAAiB,CAACE,GAAG,CAAC,UAAUC,CAAC,EAAE;IAC5C,OAAOA,CAAC,CAACpH,KAAK;EAChB,CAAC,CAAC,CAACqH,IAAI,CAAC,EAAE,CAAC;EACX,IAAI9C,gBAAgB,GAAG8B,sBAAsB,CAACa,IAAI,EAAEZ,UAAU,CAAC;EAC/D,IAAIzD,MAAM,GAAG,CAAC;EACd,IAAIyE,MAAM,GAAGL,iBAAiB,CAACE,GAAG,CAAC,UAAUpE,IAAI,EAAE;IACjDF,MAAM,IAAIE,IAAI,CAAC/C,KAAK,CAACZ,MAAM;IAC3B,OAAO;MACLyD,MAAM,EAAEA,MAAM,GAAGE,IAAI,CAAC/C,KAAK,CAACZ,MAAM;MAClCmI,MAAM,EAAExE,IAAI,CAACwE;IACf,CAAC;EACH,CAAC,CAAC;EACF,IAAIC,mBAAmB,GAAGlD,kBAAkB,CAACC,gBAAgB,EAAE2C,IAAI,EAAEzC,aAAa,CAAC;IACjFK,mBAAmB,GAAG0C,mBAAmB,CAAC1C,mBAAmB;IAC7DJ,MAAM,GAAG8C,mBAAmB,CAAC9C,MAAM;EACrC,IAAI+C,OAAO,GAAG,CAAC;EACf,IAAIC,cAAc,GAAG,CAAC;EACtB,IAAIC,MAAM,GAAGL,MAAM,CAACH,GAAG,CAAC,UAAUC,CAAC,EAAElJ,CAAC,EAAE;IACtC,IAAI2E,MAAM,GAAGuE,CAAC,CAACvE,MAAM;IACrB,IAAIF,KAAK,GAAG,CAACE,MAAM,EAAEA,MAAM,GAAGoE,iBAAiB,CAAC/I,CAAC,CAAC,CAAC8B,KAAK,CAACZ,MAAM,CAAC;IAChE,IAAIwI,WAAW,GAAGX,iBAAiB,CAAC/I,CAAC,CAAC,CAAC8B,KAAK;IAC5C,IAAI6H,kBAAkB,GAAG,EAAE;IAC3B,OAAOH,cAAc,GAAG5C,mBAAmB,CAAC1F,MAAM,IAAIsD,OAAO,CAACC,KAAK,EAAEmC,mBAAmB,CAAC4C,cAAc,CAAC,CAAC,EAAE;MACzGG,kBAAkB,CAAC9H,IAAI,CAAC+E,mBAAmB,CAAC4C,cAAc,CAAC,CAAC;MAC5DA,cAAc,EAAE;IAClB;IACA,IAAII,KAAK,GAAG,EAAE;IACd,IAAInE,MAAM,GAAG,CAAC;IACd,IAAI8D,OAAO,GAAG,CAAC,EAAE;MACf9D,MAAM,GAAG8D,OAAO;MAChBA,OAAO,GAAG,CAAC;IACb;IACAI,kBAAkB,CAAClH,OAAO,CAAC,UAAUoH,iBAAiB,EAAE;MACtD,IAAI/H,KAAK,GAAG4H,WAAW,CAACvC,MAAM,CAAC1B,MAAM,EAAEoE,iBAAiB,CAAClF,MAAM,GAAGA,MAAM,GAAGc,MAAM,CAAC;MAClF,IAAIoE,iBAAiB,CAACrB,eAAe,EAAE;QACrC,IAAIqB,iBAAiB,CAAC5E,QAAQ,KAAK,OAAO,EAAE;UAC1C,IAAInD,KAAK,CAACZ,MAAM,GAAG,CAAC,EAAE;YACpB0I,KAAK,CAAC/H,IAAI,CAAC;cACTsE,IAAI,EAAE,SAAS;cACfrE,KAAK,EAAEA;YACT,CAAC,CAAC;UACJ;QACF,CAAC,MAAM;UACL2D,MAAM,GAAGoE,iBAAiB,CAAClF,MAAM,GAAGA,MAAM,GAAGkF,iBAAiB,CAAC3I,MAAM;QACvE;QACA;MACF;MACA,IAAIY,KAAK,CAACZ,MAAM,GAAG,CAAC,EAAE;QACpB0I,KAAK,CAAC/H,IAAI,CAAC;UACTsE,IAAI,EAAE,SAAS;UACfrE,KAAK,EAAEA;QACT,CAAC,CAAC;QACF2D,MAAM,IAAI3D,KAAK,CAACZ,MAAM;MACxB;MACA,IAAI4I,aAAa,GAAG;QAClB3D,IAAI,EAAE,WAAW;QACjBlB,QAAQ,EAAE4E,iBAAiB,CAAC5E,QAAQ;QACpCN,MAAM,EAAEc,MAAM,GAAGd;MACnB,CAAC;MACDiF,KAAK,CAAC/H,IAAI,CAACiI,aAAa,CAAC;MACzBrE,MAAM,GAAGoE,iBAAiB,CAAClF,MAAM,GAAGA,MAAM,GAAGkF,iBAAiB,CAAC3I,MAAM;IACvE,CAAC,CAAC;IACFqI,OAAO,GAAG9D,MAAM,GAAGiE,WAAW,CAACxI,MAAM;IACrC,IAAIY,KAAK,GAAG4H,WAAW,CAACvC,MAAM,CAAC1B,MAAM,CAAC;IACtC,IAAI3D,KAAK,CAACZ,MAAM,GAAG,CAAC,EAAE;MACpB0I,KAAK,CAAC/H,IAAI,CAAC;QACTsE,IAAI,EAAE,SAAS;QACfrE,KAAK,EAAEA;MACT,CAAC,CAAC;IACJ;IACA,OAAO8H,KAAK;EACd,CAAC,EAAE,IAAI,CAAC;EACR,OAAO;IACLH,MAAM,EAAEA,MAAM;IACdjD,MAAM,EAAEA;EACV,CAAC;AACH;AACA,SAASuD,eAAeA,CAAClF,IAAI,EAAE;EAC7B;EACA,OAAOA,IAAI,CAACsB,IAAI,KAAK,SAAS,IAAItB,IAAI,CAACI,QAAQ,KAAK,WAAW;EAC/D;AACF;AACA,SAAS+E,eAAeA,CAACC,SAAS,EAAE;EAClC,OAAOA,SAAS,CAAC9H,MAAM,CAAC4H,eAAe,CAAC;AAC1C;AACA,SAASG,kBAAkBA,CAACD,SAAS,EAAEE,QAAQ,EAAE;EAC/C,IAAIrF,SAAS,GAAG,KAAK;EACrBmF,SAAS,CAACxH,OAAO,CAAC,UAAUoC,IAAI,EAAE;IAChCC,SAAS,GAAGF,eAAe,CAACC,IAAI,EAAEC,SAAS,CAAC;IAC5C,IAAID,IAAI,CAACsB,IAAI,KAAK,SAAS,EAAE;MAC3BtB,IAAI,CAACI,QAAQ,GAAGH,SAAS,GAAG,WAAW,GAAG,YAAY;IACxD;IACA,IAAIqF,QAAQ,KAAK,MAAM,IAAIJ,eAAe,CAAClF,IAAI,CAAC,EAAE;MAChDA,IAAI,CAAC/C,KAAK,GAAG+C,IAAI,CAAC/C,KAAK,CAACsI,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC;IAC/C;EACF,CAAC,CAAC;AACJ;AACAC,MAAM,CAACC,OAAO,GAAG;EACfxB,eAAe,EAAEA,eAAe;EAChCyB,KAAK,EAAE,SAASA,KAAKA,CAACC,QAAQ,EAAEpC,UAAU,EAAEqC,MAAM,EAAEN,QAAQ,EAAE;IAC5DD,kBAAkB,CAACM,QAAQ,EAAEL,QAAQ,CAAC;IACtC,IAAIO,gBAAgB,GAAG5B,eAAe,CAACkB,eAAe,CAACQ,QAAQ,CAAC,EAAEpC,UAAU,EAAEqC,MAAM,CAAC;MACnFE,eAAe,GAAGD,gBAAgB,CAACjB,MAAM;MACzCjD,MAAM,GAAGkE,gBAAgB,CAAClE,MAAM;IAClC,IAAIoE,KAAK,GAAG,EAAE;IACd,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIxB,MAAM,GAAG,CAAC;IACdmB,QAAQ,CAAC/H,OAAO,CAAC,UAAUoC,IAAI,EAAE;MAC/B,IAAIkF,eAAe,CAAClF,IAAI,CAAC,EAAE;QACzB/D,KAAK,CAACjB,SAAS,CAACgC,IAAI,CAACS,KAAK,CAACsI,KAAK,EAAED,eAAe,CAACE,KAAK,CAAC,CAAC5B,GAAG,CAAC,UAAUC,CAAC,EAAE;UACxE,IAAIA,CAAC,CAAC/C,IAAI,KAAK,SAAS,EAAE;YACxB+C,CAAC,CAACjE,QAAQ,GAAG,WAAW;UAC1B;UACAiE,CAAC,CAACG,MAAM,GAAGA,MAAM,EAAE;UACnB,OAAOH,CAAC;QACV,CAAC,CAAC,CAAC;QACH2B,KAAK,EAAE;MACT,CAAC,MAAM;QACLhG,IAAI,CAACwE,MAAM,GAAGA,MAAM,EAAE;QACtBuB,KAAK,CAAC/I,IAAI,CAACgD,IAAI,CAAC;MAClB;IACF,CAAC,CAAC;IACF,OAAO;MACL2B,MAAM,EAAEA,MAAM;MACdoE,KAAK,EAAEA;IACT,CAAC;EACH,CAAC;EACDE,QAAQ,EAAE,SAASA,QAAQA,CAACxF,OAAO,EAAEyF,OAAO,EAAE;IAC5C,IAAIC,OAAO,GAAG3F,UAAU,CAACC,OAAO,EAAEyF,OAAO,CAAC7E,IAAI,EAAE6E,OAAO,CAACE,KAAK,CAAC;IAC9D,IAAIxF,MAAM,GAAG,CAAC;IACd,IAAIgE,MAAM,GAAGuB,OAAO,CAACnE,MAAM,CAAC,UAAU4C,MAAM,EAAE/E,KAAK,EAAE;MACnD,IAAI5C,KAAK,GAAGwD,OAAO,CAAC6B,MAAM,CAAC1B,MAAM,EAAEf,KAAK,CAACC,MAAM,GAAGc,MAAM,CAAC;MACzD,IAAI3D,KAAK,CAACZ,MAAM,GAAG,CAAC,EAAE;QACpBuI,MAAM,CAAC5H,IAAI,CAAC;UACVsE,IAAI,EAAE,SAAS;UACfrE,KAAK,EAAEA;QACT,CAAC,CAAC;MACJ;MACA2D,MAAM,GAAGf,KAAK,CAACC,MAAM,GAAGD,KAAK,CAAC5C,KAAK,CAACZ,MAAM;MAC1C,OAAOwD,KAAK,CAACC,MAAM;MACnB8E,MAAM,CAAC5H,IAAI,CAAC6C,KAAK,CAAC;MAClB,OAAO+E,MAAM;IACf,CAAC,EAAE,EAAE,CAAC;IACN,IAAI3H,KAAK,GAAGwD,OAAO,CAAC6B,MAAM,CAAC1B,MAAM,CAAC;IAClC,IAAI3D,KAAK,CAACZ,MAAM,GAAG,CAAC,EAAE;MACpBuI,MAAM,CAAC5H,IAAI,CAAC;QACVsE,IAAI,EAAE,SAAS;QACfrE,KAAK,EAAEA;MACT,CAAC,CAAC;IACJ;IACA,OAAO2H,MAAM;EACf;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}