{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nvar _require = require(\"./doc-utils.js\"),\n  getRightOrNull = _require.getRightOrNull,\n  getRight = _require.getRight,\n  getLeft = _require.getLeft,\n  getLeftOrNull = _require.getLeftOrNull,\n  chunkBy = _require.chunkBy,\n  isTagStart = _require.isTagStart,\n  isTagEnd = _require.isTagEnd,\n  isContent = _require.isContent,\n  last = _require.last,\n  first = _require.first;\nvar _require2 = require(\"./errors.js\"),\n  XTTemplateError = _require2.XTTemplateError,\n  throwExpandNotFound = _require2.throwExpandNotFound,\n  getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\nfunction lastTagIsOpenTag(tags, tag) {\n  if (tags.length === 0) {\n    return false;\n  }\n  var innerLastTag = last(tags).substr(1);\n  return innerLastTag.indexOf(tag) === 0;\n}\nfunction getListXmlElements(parts) {\n  /*\n  Gets the list of closing and opening tags between two texts. It doesn't take\n  into account tags that are opened then closed. Those that are closed then\n  opened are kept\n  \tExample input :\n  \t[\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"table1\",\n  \t\t...\n  \t},\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"t1data1\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"position\": \"end\",\n  \t\t\"text\": true,\n  \t\t\"value\": \"</w:t>\",\n  \t\t\"tag\": \"w:t\",\n  \t\t\"lIndex\": 112\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:r>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:p>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:tc>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:tc>\",\n  \t},\n  \t{\n  \t\t\"type\": \"content\",\n  \t\t\"value\": \"<w:tcPr><w:tcW w:w=\"2444\" w:type=\"dxa\"/><w:tcBorders><w:top w:val=\"nil\"/><w:left w:val=\"nil\"/><w:bottom w:val=\"nil\"/><w:right w:val=\"nil\"/></w:tcBorders><w:shd w:val=\"clear\" w:color=\"auto\" w:fill=\"FFFFFF\"/></w:tcPr>\",\n  \t},\n  \t...\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:r>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:t xml:space=\"preserve\">\",\n  \t},\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"t1data4\",\n  \t}\n  ]\n  \treturns\n  \t[\n  \t\t{\n  \t\t\t\"tag\": \"</w:t>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:r>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:p>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:tc>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:tc>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:p>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:r>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:t>\",\n  \t\t},\n  \t]\n  */\n\n  var result = [];\n  for (var i = 0; i < parts.length; i++) {\n    var _parts$i = parts[i],\n      position = _parts$i.position,\n      value = _parts$i.value,\n      tag = _parts$i.tag;\n    // Stryker disable all : because removing this condition would also work but we want to make the API future proof\n    if (!tag) {\n      continue;\n    }\n    // Stryker restore all\n    if (position === \"end\") {\n      if (lastTagIsOpenTag(result, tag)) {\n        result.pop();\n      } else {\n        result.push(value);\n      }\n    } else if (position === \"start\") {\n      result.push(value);\n    }\n    // ignore position === \"selfclosing\"\n  }\n  return result;\n}\nfunction has(name, xmlElements) {\n  for (var i = 0; i < xmlElements.length; i++) {\n    var xmlElement = xmlElements[i];\n    if (xmlElement.indexOf(\"<\".concat(name)) === 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n  var parts = postparsed.slice(pair[0].offset, pair[1].offset);\n  var xmlElements = getListXmlElements(parts);\n  var closingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] === \"/\";\n  }).length;\n  var startingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n  }).length;\n  if (closingTagCount !== startingTagCount) {\n    return {\n      error: getLoopPositionProducesInvalidXMLError({\n        tag: first(pair).part.value,\n        offset: [first(pair).part.offset, last(pair).part.offset]\n      })\n    };\n  }\n  var _loop = function _loop() {\n      var _expandTags$i = expandTags[i],\n        contains = _expandTags$i.contains,\n        expand = _expandTags$i.expand,\n        onlyTextInTag = _expandTags$i.onlyTextInTag;\n      if (has(contains, xmlElements)) {\n        if (onlyTextInTag) {\n          var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n          var right = getRightOrNull(postparsed, contains, pair[1].offset);\n          if (left === null || right === null) {\n            return 0; // continue\n          }\n          var chunks = chunkBy(postparsed.slice(left, right), function (p) {\n            return isTagStart(contains, p) ? \"start\" : isTagEnd(contains, p) ? \"end\" : null;\n          });\n          var firstChunk = first(chunks);\n          var lastChunk = last(chunks);\n          var firstContent = firstChunk.filter(isContent);\n          var lastContent = lastChunk.filter(isContent);\n          if (firstContent.length !== 1 || lastContent.length !== 1) {\n            return 0; // continue\n          }\n        }\n        return {\n          v: {\n            value: expand\n          }\n        };\n      }\n    },\n    _ret;\n  for (var i = 0, len = expandTags.length; i < len; i++) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n    if (_ret) return _ret.v;\n  }\n  return {};\n}\nfunction getExpandLimit(part, index, postparsed, options) {\n  var expandTo = part.expandTo || options.expandTo;\n  // Stryker disable all : because this condition can be removed in v4 (the only usage was the image module before version 3.12.3 of the image module\n  if (!expandTo) {\n    return;\n  }\n  // Stryker restore all\n  var right, left;\n  try {\n    left = getLeft(postparsed, expandTo, index);\n    right = getRight(postparsed, expandTo, index);\n  } catch (rootError) {\n    if (rootError instanceof XTTemplateError) {\n      throwExpandNotFound(_objectSpread({\n        part: part,\n        rootError: rootError,\n        postparsed: postparsed,\n        expandTo: expandTo,\n        index: index\n      }, options.error));\n    }\n    throw rootError;\n  }\n  return [left, right];\n}\nfunction expandOne(_ref, part, postparsed, options) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    left = _ref2[0],\n    right = _ref2[1];\n  var index = postparsed.indexOf(part);\n  var leftParts = postparsed.slice(left, index);\n  var rightParts = postparsed.slice(index + 1, right + 1);\n  var inner = options.getInner({\n    postparse: options.postparse,\n    index: index,\n    part: part,\n    leftParts: leftParts,\n    rightParts: rightParts,\n    left: left,\n    right: right,\n    postparsed: postparsed\n  });\n  if (!inner.length) {\n    inner.expanded = [leftParts, rightParts];\n    inner = [inner];\n  }\n  return {\n    left: left,\n    right: right,\n    inner: inner\n  };\n}\nfunction expandToOne(postparsed, options) {\n  var errors = [];\n  if (postparsed.errors) {\n    errors = postparsed.errors;\n    postparsed = postparsed.postparsed;\n  }\n  var limits = [];\n  for (var i = 0, len = postparsed.length; i < len; i++) {\n    var part = postparsed[i];\n    if (part.type === \"placeholder\" && part.module === options.moduleName &&\n    // The part.subparsed check is used to fix this github issue :\n    // https://github.com/open-xml-templating/docxtemplater/issues/671\n    !part.subparsed && !part.expanded) {\n      try {\n        var limit = getExpandLimit(part, i, postparsed, options);\n        if (!limit) {\n          continue;\n        }\n        var _limit = _slicedToArray(limit, 2),\n          left = _limit[0],\n          right = _limit[1];\n        limits.push({\n          left: left,\n          right: right,\n          part: part,\n          i: i,\n          leftPart: postparsed[left],\n          rightPart: postparsed[right]\n        });\n      } catch (error) {\n        if (error instanceof XTTemplateError) {\n          errors.push(error);\n        } else {\n          throw error;\n        }\n      }\n    }\n  }\n  limits.sort(function (l1, l2) {\n    if (l1.left === l2.left) {\n      return l2.part.lIndex < l1.part.lIndex ? 1 : -1;\n    }\n    return l2.left < l1.left ? 1 : -1;\n  });\n  var maxRight = -1;\n  var offset = 0;\n  limits.forEach(function (limit, i) {\n    var _postparsed;\n    maxRight = Math.max(maxRight, i > 0 ? limits[i - 1].right : 0);\n    if (limit.left < maxRight) {\n      return;\n    }\n    var result;\n    try {\n      result = expandOne([limit.left + offset, limit.right + offset], limit.part, postparsed, options);\n    } catch (error) {\n      if (error instanceof XTTemplateError) {\n        errors.push(error);\n      } else {\n        throw error;\n      }\n    }\n    if (!result) {\n      return;\n    }\n    offset += result.inner.length - (result.right + 1 - result.left);\n    (_postparsed = postparsed).splice.apply(_postparsed, [result.left, result.right + 1 - result.left].concat(_toConsumableArray(result.inner)));\n  });\n  return {\n    postparsed: postparsed,\n    errors: errors\n  };\n}\nmodule.exports = {\n  expandToOne: expandToOne,\n  getExpandToDefault: getExpandToDefault\n};","map":{"version":3,"names":["_typeof","o","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Array","from","isArray","_arrayLikeToArray","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","minLen","n","Object","toString","call","slice","name","test","len","length","arr2","r","l","t","e","u","a","f","next","done","push","value","ownKeys","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","enumerable","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","key","_toPropertyKey","configurable","writable","_toPrimitive","toPrimitive","String","Number","_require","require","getRightOrNull","getRight","getLeft","getLeftOrNull","chunkBy","isTagStart","isTagEnd","isContent","last","first","_require2","XTTemplateError","throwExpandNotFound","getLoopPositionProducesInvalidXMLError","lastTagIsOpenTag","tags","tag","innerLastTag","substr","indexOf","getListXmlElements","parts","result","_parts$i","position","pop","has","xmlElements","xmlElement","concat","getExpandToDefault","postparsed","pair","expandTags","offset","closingTagCount","startingTagCount","error","part","_loop","_expandTags$i","contains","expand","onlyTextInTag","left","right","chunks","p","firstChunk","lastChunk","firstContent","lastContent","v","_ret","getExpandLimit","index","options","expandTo","rootError","expandOne","_ref","_ref2","leftParts","rightParts","inner","getInner","postparse","expanded","expandToOne","errors","limits","type","module","moduleName","subparsed","limit","_limit","leftPart","rightPart","sort","l1","l2","lIndex","maxRight","_postparsed","Math","max","splice","exports"],"sources":["C:/study/react project/client/node_modules/docxtemplater/js/traits.js"],"sourcesContent":["\"use strict\";\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = require(\"./doc-utils.js\"),\n  getRightOrNull = _require.getRightOrNull,\n  getRight = _require.getRight,\n  getLeft = _require.getLeft,\n  getLeftOrNull = _require.getLeftOrNull,\n  chunkBy = _require.chunkBy,\n  isTagStart = _require.isTagStart,\n  isTagEnd = _require.isTagEnd,\n  isContent = _require.isContent,\n  last = _require.last,\n  first = _require.first;\nvar _require2 = require(\"./errors.js\"),\n  XTTemplateError = _require2.XTTemplateError,\n  throwExpandNotFound = _require2.throwExpandNotFound,\n  getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\nfunction lastTagIsOpenTag(tags, tag) {\n  if (tags.length === 0) {\n    return false;\n  }\n  var innerLastTag = last(tags).substr(1);\n  return innerLastTag.indexOf(tag) === 0;\n}\nfunction getListXmlElements(parts) {\n  /*\n  Gets the list of closing and opening tags between two texts. It doesn't take\n  into account tags that are opened then closed. Those that are closed then\n  opened are kept\n  \tExample input :\n  \t[\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"table1\",\n  \t\t...\n  \t},\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"t1data1\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"position\": \"end\",\n  \t\t\"text\": true,\n  \t\t\"value\": \"</w:t>\",\n  \t\t\"tag\": \"w:t\",\n  \t\t\"lIndex\": 112\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:r>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:p>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:tc>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:tc>\",\n  \t},\n  \t{\n  \t\t\"type\": \"content\",\n  \t\t\"value\": \"<w:tcPr><w:tcW w:w=\"2444\" w:type=\"dxa\"/><w:tcBorders><w:top w:val=\"nil\"/><w:left w:val=\"nil\"/><w:bottom w:val=\"nil\"/><w:right w:val=\"nil\"/></w:tcBorders><w:shd w:val=\"clear\" w:color=\"auto\" w:fill=\"FFFFFF\"/></w:tcPr>\",\n  \t},\n  \t...\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:r>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:t xml:space=\"preserve\">\",\n  \t},\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"t1data4\",\n  \t}\n  ]\n  \treturns\n  \t[\n  \t\t{\n  \t\t\t\"tag\": \"</w:t>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:r>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:p>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:tc>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:tc>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:p>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:r>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:t>\",\n  \t\t},\n  \t]\n  */\n\n  var result = [];\n  for (var i = 0; i < parts.length; i++) {\n    var _parts$i = parts[i],\n      position = _parts$i.position,\n      value = _parts$i.value,\n      tag = _parts$i.tag;\n    // Stryker disable all : because removing this condition would also work but we want to make the API future proof\n    if (!tag) {\n      continue;\n    }\n    // Stryker restore all\n    if (position === \"end\") {\n      if (lastTagIsOpenTag(result, tag)) {\n        result.pop();\n      } else {\n        result.push(value);\n      }\n    } else if (position === \"start\") {\n      result.push(value);\n    }\n    // ignore position === \"selfclosing\"\n  }\n  return result;\n}\nfunction has(name, xmlElements) {\n  for (var i = 0; i < xmlElements.length; i++) {\n    var xmlElement = xmlElements[i];\n    if (xmlElement.indexOf(\"<\".concat(name)) === 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n  var parts = postparsed.slice(pair[0].offset, pair[1].offset);\n  var xmlElements = getListXmlElements(parts);\n  var closingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] === \"/\";\n  }).length;\n  var startingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n  }).length;\n  if (closingTagCount !== startingTagCount) {\n    return {\n      error: getLoopPositionProducesInvalidXMLError({\n        tag: first(pair).part.value,\n        offset: [first(pair).part.offset, last(pair).part.offset]\n      })\n    };\n  }\n  var _loop = function _loop() {\n      var _expandTags$i = expandTags[i],\n        contains = _expandTags$i.contains,\n        expand = _expandTags$i.expand,\n        onlyTextInTag = _expandTags$i.onlyTextInTag;\n      if (has(contains, xmlElements)) {\n        if (onlyTextInTag) {\n          var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n          var right = getRightOrNull(postparsed, contains, pair[1].offset);\n          if (left === null || right === null) {\n            return 0; // continue\n          }\n          var chunks = chunkBy(postparsed.slice(left, right), function (p) {\n            return isTagStart(contains, p) ? \"start\" : isTagEnd(contains, p) ? \"end\" : null;\n          });\n          var firstChunk = first(chunks);\n          var lastChunk = last(chunks);\n          var firstContent = firstChunk.filter(isContent);\n          var lastContent = lastChunk.filter(isContent);\n          if (firstContent.length !== 1 || lastContent.length !== 1) {\n            return 0; // continue\n          }\n        }\n        return {\n          v: {\n            value: expand\n          }\n        };\n      }\n    },\n    _ret;\n  for (var i = 0, len = expandTags.length; i < len; i++) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n    if (_ret) return _ret.v;\n  }\n  return {};\n}\nfunction getExpandLimit(part, index, postparsed, options) {\n  var expandTo = part.expandTo || options.expandTo;\n  // Stryker disable all : because this condition can be removed in v4 (the only usage was the image module before version 3.12.3 of the image module\n  if (!expandTo) {\n    return;\n  }\n  // Stryker restore all\n  var right, left;\n  try {\n    left = getLeft(postparsed, expandTo, index);\n    right = getRight(postparsed, expandTo, index);\n  } catch (rootError) {\n    if (rootError instanceof XTTemplateError) {\n      throwExpandNotFound(_objectSpread({\n        part: part,\n        rootError: rootError,\n        postparsed: postparsed,\n        expandTo: expandTo,\n        index: index\n      }, options.error));\n    }\n    throw rootError;\n  }\n  return [left, right];\n}\nfunction expandOne(_ref, part, postparsed, options) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    left = _ref2[0],\n    right = _ref2[1];\n  var index = postparsed.indexOf(part);\n  var leftParts = postparsed.slice(left, index);\n  var rightParts = postparsed.slice(index + 1, right + 1);\n  var inner = options.getInner({\n    postparse: options.postparse,\n    index: index,\n    part: part,\n    leftParts: leftParts,\n    rightParts: rightParts,\n    left: left,\n    right: right,\n    postparsed: postparsed\n  });\n  if (!inner.length) {\n    inner.expanded = [leftParts, rightParts];\n    inner = [inner];\n  }\n  return {\n    left: left,\n    right: right,\n    inner: inner\n  };\n}\nfunction expandToOne(postparsed, options) {\n  var errors = [];\n  if (postparsed.errors) {\n    errors = postparsed.errors;\n    postparsed = postparsed.postparsed;\n  }\n  var limits = [];\n  for (var i = 0, len = postparsed.length; i < len; i++) {\n    var part = postparsed[i];\n    if (part.type === \"placeholder\" && part.module === options.moduleName &&\n    // The part.subparsed check is used to fix this github issue :\n    // https://github.com/open-xml-templating/docxtemplater/issues/671\n    !part.subparsed && !part.expanded) {\n      try {\n        var limit = getExpandLimit(part, i, postparsed, options);\n        if (!limit) {\n          continue;\n        }\n        var _limit = _slicedToArray(limit, 2),\n          left = _limit[0],\n          right = _limit[1];\n        limits.push({\n          left: left,\n          right: right,\n          part: part,\n          i: i,\n          leftPart: postparsed[left],\n          rightPart: postparsed[right]\n        });\n      } catch (error) {\n        if (error instanceof XTTemplateError) {\n          errors.push(error);\n        } else {\n          throw error;\n        }\n      }\n    }\n  }\n  limits.sort(function (l1, l2) {\n    if (l1.left === l2.left) {\n      return l2.part.lIndex < l1.part.lIndex ? 1 : -1;\n    }\n    return l2.left < l1.left ? 1 : -1;\n  });\n  var maxRight = -1;\n  var offset = 0;\n  limits.forEach(function (limit, i) {\n    var _postparsed;\n    maxRight = Math.max(maxRight, i > 0 ? limits[i - 1].right : 0);\n    if (limit.left < maxRight) {\n      return;\n    }\n    var result;\n    try {\n      result = expandOne([limit.left + offset, limit.right + offset], limit.part, postparsed, options);\n    } catch (error) {\n      if (error instanceof XTTemplateError) {\n        errors.push(error);\n      } else {\n        throw error;\n      }\n    }\n    if (!result) {\n      return;\n    }\n    offset += result.inner.length - (result.right + 1 - result.left);\n    (_postparsed = postparsed).splice.apply(_postparsed, [result.left, result.right + 1 - result.left].concat(_toConsumableArray(result.inner)));\n  });\n  return {\n    postparsed: postparsed,\n    errors: errors\n  };\n}\nmodule.exports = {\n  expandToOne: expandToOne,\n  getExpandToDefault: getExpandToDefault\n};"],"mappings":"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AsC,GAAGH,SAAS,CAACG,sCAAsC;AAC3F,SAASC,gBAAgBA,CAACC,IAAI,EAAEC,GAAG,EAAE;EACnC,IAAID,IAAI,CAACrD,MAAM,KAAK,CAAC,EAAE;IACrB,OAAO,KAAK;EACd;EACA,IAAIuD,YAAY,GAAGT,IAAI,CAACO,IAAI,CAAC,CAACG,MAAM,CAAC,CAAC,CAAC;EACvC,OAAOD,YAAY,CAACE,OAAO,CAACH,GAAG,CAAC,KAAK,CAAC;AACxC;AACA,SAASI,kBAAkBA,CAACC,KAAK,EAAE;EACjC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,IAAIzE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwE,KAAK,CAAC3D,MAAM,EAAEb,CAAC,EAAE,EAAE;IACrC,IAAI0E,QAAQ,GAAGF,KAAK,CAACxE,CAAC,CAAC;MACrB2E,QAAQ,GAAGD,QAAQ,CAACC,QAAQ;MAC5BlD,KAAK,GAAGiD,QAAQ,CAACjD,KAAK;MACtB0C,GAAG,GAAGO,QAAQ,CAACP,GAAG;IACpB;IACA,IAAI,CAACA,GAAG,EAAE;MACR;IACF;IACA;IACA,IAAIQ,QAAQ,KAAK,KAAK,EAAE;MACtB,IAAIV,gBAAgB,CAACQ,MAAM,EAAEN,GAAG,CAAC,EAAE;QACjCM,MAAM,CAACG,GAAG,CAAC,CAAC;MACd,CAAC,MAAM;QACLH,MAAM,CAACjD,IAAI,C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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}