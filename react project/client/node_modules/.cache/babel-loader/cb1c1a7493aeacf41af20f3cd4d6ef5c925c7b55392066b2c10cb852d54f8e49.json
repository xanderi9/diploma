{"ast":null,"code":"\"use strict\";\n\nvar _require = require(\"./doc-utils.js\"),\n  startsWith = _require.startsWith,\n  endsWith = _require.endsWith,\n  isStarting = _require.isStarting,\n  isEnding = _require.isEnding,\n  isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = require(\"./filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n  var lastNonEmpty = \"\";\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var p = parts[i];\n    if (isWhiteSpace(p)) {\n      continue;\n    }\n    if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n      if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\")) {\n        p = \"<w:p/>\".concat(p);\n      }\n    }\n    lastNonEmpty = p;\n    parts[i] = p;\n  }\n  return parts;\n}\n\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || [];\n  /* Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   */\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n  if (filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n  var startIndex = -1;\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var part = parts[i];\n    for (var j = 0, len2 = contains.length; j < len2; j++) {\n      var _contains$j = contains[j],\n        tag = _contains$j.tag,\n        shouldContain = _contains$j.shouldContain,\n        value = _contains$j.value,\n        drop = _contains$j.drop,\n        dropParent = _contains$j.dropParent;\n      if (currentlyCollecting === j) {\n        if (isEnding(part, tag)) {\n          currentlyCollecting = -1;\n          if (dropParent) {\n            var start = void 0,\n              end = void 0;\n            for (var k = startIndex; k > 0; k--) {\n              if (isStarting(parts[k], dropParent)) {\n                start = k;\n                break;\n              }\n            }\n            for (var _k = i; _k < parts.length; _k++) {\n              if (isEnding(parts[_k], dropParent)) {\n                end = _k;\n                break;\n              }\n            }\n            for (var _k2 = start; _k2 <= end; _k2++) {\n              parts[_k2] = \"\";\n            }\n          } else if (drop) {\n            for (var _k3 = startIndex; _k3 <= i; _k3++) {\n              parts[_k3] = \"\";\n            }\n          } else {\n            for (var _k4 = startIndex; _k4 < i; _k4++) {\n              parts[_k4] = \"\";\n            }\n            parts[i] = collecting + value + part;\n          }\n          break;\n        }\n        collecting += part;\n        for (var _k5 = 0, len3 = shouldContain.length; _k5 < len3; _k5++) {\n          var sc = shouldContain[_k5];\n          if (isStarting(part, sc)) {\n            currentlyCollecting = -1;\n            // parts[i] = collecting;\n            break;\n          }\n        }\n        if (currentlyCollecting > -1) {\n          // parts[i] = \"\";\n        }\n        break;\n      }\n      if (currentlyCollecting === -1 && isStarting(part, tag) &&\n      // to verify that the part doesn't have multiple tags, such as <w:tc><w:p>\n      part.substr(1).indexOf(\"<\") === -1) {\n        // self-closing tag such as <w:t/>\n        if (part[part.length - 2] === \"/\") {\n          parts[i] = \"\";\n          break;\n        } else {\n          startIndex = i;\n          currentlyCollecting = j;\n          collecting = part;\n          // parts[i] = \"\";\n          break;\n        }\n      }\n    }\n  }\n  return parts;\n}\nmodule.exports = joinUncorrupt;","map":{"version":3,"names":["_require","require","startsWith","endsWith","isStarting","isEnding","isWhiteSpace","filetypes","addEmptyParagraphAfterTable","parts","lastNonEmpty","i","len","length","p","concat","joinUncorrupt","options","contains","fileTypeConfig","tagShouldContain","collecting","currentlyCollecting","docx","indexOf","contentType","startIndex","part","j","len2","_contains$j","tag","shouldContain","value","drop","dropParent","start","end","k","_k","_k2","_k3","_k4","_k5","len3","sc","substr","module","exports"],"sources":["C:/study/react project/client/node_modules/docxtemplater/js/join-uncorrupt.js"],"sourcesContent":["\"use strict\";\n\nvar _require = require(\"./doc-utils.js\"),\n  startsWith = _require.startsWith,\n  endsWith = _require.endsWith,\n  isStarting = _require.isStarting,\n  isEnding = _require.isEnding,\n  isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = require(\"./filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n  var lastNonEmpty = \"\";\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var p = parts[i];\n    if (isWhiteSpace(p)) {\n      continue;\n    }\n    if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n      if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\")) {\n        p = \"<w:p/>\".concat(p);\n      }\n    }\n    lastNonEmpty = p;\n    parts[i] = p;\n  }\n  return parts;\n}\n\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || [];\n  /* Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   */\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n  if (filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n  var startIndex = -1;\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var part = parts[i];\n    for (var j = 0, len2 = contains.length; j < len2; j++) {\n      var _contains$j = contains[j],\n        tag = _contains$j.tag,\n        shouldContain = _contains$j.shouldContain,\n        value = _contains$j.value,\n        drop = _contains$j.drop,\n        dropParent = _contains$j.dropParent;\n      if (currentlyCollecting === j) {\n        if (isEnding(part, tag)) {\n          currentlyCollecting = -1;\n          if (dropParent) {\n            var start = void 0,\n              end = void 0;\n            for (var k = startIndex; k > 0; k--) {\n              if (isStarting(parts[k], dropParent)) {\n                start = k;\n                break;\n              }\n            }\n            for (var _k = i; _k < parts.length; _k++) {\n              if (isEnding(parts[_k], dropParent)) {\n                end = _k;\n                break;\n              }\n            }\n            for (var _k2 = start; _k2 <= end; _k2++) {\n              parts[_k2] = \"\";\n            }\n          } else if (drop) {\n            for (var _k3 = startIndex; _k3 <= i; _k3++) {\n              parts[_k3] = \"\";\n            }\n          } else {\n            for (var _k4 = startIndex; _k4 < i; _k4++) {\n              parts[_k4] = \"\";\n            }\n            parts[i] = collecting + value + part;\n          }\n          break;\n        }\n        collecting += part;\n        for (var _k5 = 0, len3 = shouldContain.length; _k5 < len3; _k5++) {\n          var sc = shouldContain[_k5];\n          if (isStarting(part, sc)) {\n            currentlyCollecting = -1;\n            // parts[i] = collecting;\n            break;\n          }\n        }\n        if (currentlyCollecting > -1) {\n          // parts[i] = \"\";\n        }\n        break;\n      }\n      if (currentlyCollecting === -1 && isStarting(part, tag) &&\n      // to verify that the part doesn't have multiple tags, such as <w:tc><w:p>\n      part.substr(1).indexOf(\"<\") === -1) {\n        // self-closing tag such as <w:t/>\n        if (part[part.length - 2] === \"/\") {\n          parts[i] = \"\";\n          break;\n        } else {\n          startIndex = i;\n          currentlyCollecting = j;\n          collecting = part;\n          // parts[i] = \"\";\n          break;\n        }\n      }\n    }\n  }\n  return parts;\n}\nmodule.exports = joinUncorrupt;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}